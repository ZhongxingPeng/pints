#
# Nested rejection sampler implementation.
#
# This file is part of PINTS.
#  Copyright (c) 2017-2018, University of Oxford.
#  For licensing information, see the LICENSE file distributed with the PINTS
#  software package.
#
#
from __future__ import absolute_import, division
from __future__ import print_function, unicode_literals
import pints
import numpy as np


class GalileanMC(pints.NestedSampler):
    """
    Implements Galilean Monte Carlo sampling as described in
    [1,2]. This is a type of nested sampling algorithm [3].
    The difference between this and simple rejected
    nested sampling is that the proposed active points
    are generated by choosing a random particle
    with position x to update. Then a random velocity is picked
    and the proposed location x' = x + v, where v ~ N(0,Sigma).
    The point is accepted if and only if its log-likelihood is higher than
    the threshold. If it is not, then a new location is given by
    x'' = x' + v', where v'= v - 2 * n.v, where n=grad(log_L).
    By default, this method uses a finite difference scheme to approximate
    the gradient (specifically, central differences), but will later be
    changed to allow a user to pass sensitivities
    """
    def __init__(self, log_likelihood, log_prior):
        super(GalileanMC, self).__init__(log_likelihood, log_prior)

        # By default use random updates
        self._random_propose = True
        self._mu = None
        self._sigma = None

        self._first_proposal = True

        # Derivative length
        self._epsilon = 10**(-8)

    def set_random_propose(self, random_ind, mu=None, sigma=None):
        """
        Sets the method used for proposing velocity. If
        random_ind is true (the default) then use an identity
        matrix
        """
        random_ind = bool(random_ind)
        if not random_ind:
            self._mu = mu
            self._sigma = sigma
        self._random_propose = random_ind

    def ask(self):
        """
        Yields a point using Galilean Monte Carlo method. If first attempt
        then select a random active point, then draw a random velocity then
        move particle; if 2nd attempt do reflection move on existing
        """
        if self._first_proposal:
            ind = np.random.randint(self._active_points)
            self._x = self._m_active[ind, 0:self._dimension]
            self._velocity = self._propose_velocity()
            self._x = self._x + self._velocity
        else:
            self._x = self._reflect(self._x, self._velocity)
        return self._x

    def _derivative(self, x):
        """
        Calculates an approximate gradient via finite differences
        using a central differencing scheme
        """
        v_gradient = np.zeros(self._dimension)
        for i in range(self._dimension):
            x_temp_upper = np.copy(x)
            x_temp_upper[i] += self._epsilon
            x_temp_lower = np.copy(x)
            x_temp_lower[i] -= self._epsilon
            v_gradient[i] = (
                self._log_likelihood(x_temp_upper) -
                self._log_likelihood(x_temp_lower) / (2 * self._epsilon)
            )
            self._n_evals += 2
        return v_gradient

    def _propose_velocity(self):
        """
        Proposes a velocity to generate new active particle
        in parameter space
        """
        if self._random_propose:
            velocity = np.random.multivariate_normal(
                np.zeros(self._dimension), np.identity(self._dimension)
            )
        else:
            velocity = np.random.multivariate_normal(
                np.zeros(self._dimension), self._sigma
            )
        return velocity

    def _reflect(self, x, v):
        """
        Calculates an approximate finite difference approximation
        of the derivative of the likelihood at x and uses it to construct
        a unit normal vector with which to reflect particle
        """
        grad = self._derivative(x)
        n = grad / np.sum(grad)
        # new velocity
        v1 = v - 2 * np.dot(n, v)
        x1 = x + v1
        return x1

    def name(self):
        """ See :meth:`pints.NestedSampler.name()`. """
        return 'Galilean Monte Carlo (Nested) sampler'
